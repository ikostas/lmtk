import os # remove old files
import threading # to unfreese the UI
import pythoncom # for hardware detection
import markdown # convert report from markdown to html
import tkinter as tk # UI
from tkinter import ttk # UI
from tkinter import font # UI
import webbrowser # open links in standard browser
import subprocess # execute PowerShell scripts for hardware detection
import re # edit text files, generated by PowerShell
import wmi # hardware detection in Windows
from datetime import datetime # timestamp in report

class AppContext():
  def __init__(self):
    self._root = tk.Tk()
    self._root.geometry("900x800")
    self._root.resizable(True, True)
    self._standard_apps_txt = "installed_standard_apps.txt"
    self._standard_apps_md = "cleaned_standard_apps.md"
    self._store_apps_txt = "installed_store_apps.txt"
    self._store_apps_md = "cleaned_store_apps.md"
    self._hw_report_md = "hardware_info.md"
    self._md_report = "swhw_report.md"
    self._html_report = "swhw_report.html"

  def run(self):
    self._root.mainloop()

  def start_progress(self):
    self.progress = ttk.Progressbar(self._root, mode="indeterminate")
    self.progress.pack()
    self.progress.start()
    threading.Thread(target=lambda: get_info_thread(context), daemon=True).start()

  def stop_progress(self):
    self.progress.stop()
    self.progress.pack_forget()

  def set_root_title(self, title):
    self._root.title(title)

  def set_root_label(self, title):
    title_label = ttk.Label(self.root, text=title, font=("Helvetica", 11, "bold"))
    title_label.pack(pady=20)

  def quit_button(self):
    quit_button = ttk.Button(self.root, text="Quit", command=self.root.destroy)
    quit_button.pack(pady=10)

  @property
  def root(self):
    return self._root

  @property
  def standard_apps_txt(self):
    return self._standard_apps_txt 

  @property
  def standard_apps_md(self):
    return self._standard_apps_md
  
  @property
  def store_apps_txt(self):
    return self._store_apps_txt

  @property
  def store_apps_md(self):
    return self._store_apps_md

  @property
  def hw_report_md(self):
    return self._hw_report_md
  
  @property
  def md_report(self):
    return self._md_report

  @property
  def html_report(self):
    return self._html_report

def open_link(link):
  webbrowser.open_new(link)

def get_status(step_index, isNovice, context: AppContext):
  normal_font = font.Font(family="Helvetica", size=11)
  bold_font = font.Font(family="Helvetica", size=11, weight="bold")
  if isNovice:
    steps = ["0. Intro", "1. Gather Info", "2. Backup", "3. Prepare Media"]
  else:
    steps = ["1. Gather Info", "2. Backup", "3. Prepare Media"]

  status_frame = tk.Frame(context.root)
  status_frame.pack(pady=10, anchor="n")
  for i, step in enumerate(steps):
    lbl_font = bold_font if i == step_index else normal_font
    label = tk.Label(status_frame, text=step, font=lbl_font)
    label.pack(side="left")

    if i < len(steps) - 1:
      sep = tk.Label(status_frame, text=" > ", font=normal_font)
      sep.pack(side="left")

def markdown_to_html(context: AppContext):
  # Read markdown content
  with open(context.md_report, "r", encoding="utf-8") as f:
    text = f.read()

  # Convert to HTML
  html = markdown.markdown(text, extensions=["fenced_code", "tables", "toc", "attr_list"])

  # Wrap in basic HTML boilerplate
  full_html = f"""<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Linux Migration Toolkit Report</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
</head>
<body>
<main class="container">
{html}
</main>
</body>
</html>
"""

  # Write HTML file
  with open(context.html_report, "w", encoding="utf-8") as f:
    f.write(full_html)

def get_hwsw_report(context: AppContext):
  file1 = context.standard_apps_md
  file2 = context.store_apps_md
  file3 = context.hw_report_md
  output_file = context.md_report
  # Titles
  main_title = "# Linux Migration Toolkit Report"
  timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
  sections = [
    ("## Standard Applications", file1),
    ("## Microsoft Store Applications", file2),
    ("## Hardware Information", file3),
]

  # Combine files into one markdown report
  with open(output_file, "w", encoding="utf-8") as out:
    out.write(f"""
{main_title}

*Generated on {timestamp}*

## What do I do with this information?

You can use this report to:

- Check your hardware's compatibility with Linux.
- Find Linux alternatives for the Windows programs you currently use.

Helpful resources:

- [Ubuntu Hardware Support Wiki](https://wiki.ubuntu.com/HardwareSupport)
- [Linux software equivalents to Windows software](https://wiki.linuxquestions.org/wiki/Linux_software_equivalent_to_Windows_software)\n\n

## Table of Contents

- [Standard Applications](#standard-applications) &dash; these apps are installed, when you download and installation file and launch it
- [Microsoft Store Applications](#microsoft-store-applications) &dash; these are the apps, installed from Microsoft Store
- [Hardware Information](#hardware-information) &dash; some basic information about your system: CPU, GPU, RAM, HDD/SSD\n
""")

    for header, filename in sections:
      out.write(f"{header}\n\n")
      with open(filename, "r", encoding="utf-8") as f:
        out.write(f.read().strip() + "\n\n")

  # Remove original files
  for _, filename in sections:
    try:
      os.remove(filename)
    except OSError as e:
      print(f"Error deleting {filename}: {e}")

def get_hw_info(context: AppContext):
  filename = context.hw_report_md
  pythoncom.CoInitialize()
  try:
    c = wmi.WMI()
    lines = []

    # CPU info
    cpus = c.Win32_Processor()
    lines.append("### CPU:\n")
    for cpu in cpus:
      lines.append(f"- Name: {cpu.Name}")
      lines.append(f"- Number of Cores: {cpu.NumberOfCores}")

    # RAM info (in GB)
    system_info = c.Win32_ComputerSystem()[0]
    total_ram_bytes = int(system_info.TotalPhysicalMemory)
    total_ram_gb = total_ram_bytes / (1024 ** 3)
    lines.append(f"\n### RAM:\n\n- {total_ram_gb:.2f} GB")

    # Drives info
    drives = c.Win32_LogicalDisk(DriveType=3)  # local disks only
    lines.append("\n### Drives:\n")
    for drive in drives:
      size_gb = int(drive.Size) / (1024 ** 3) if drive.Size else 0
      free_gb = int(drive.FreeSpace) / (1024 ** 3) if drive.FreeSpace else 0
      lines.append(f"- {drive.DeviceID} - Size: {size_gb:.2f} GB, Free: {free_gb:.2f} GB")

    # GPU info
    gpus = c.Win32_VideoController()
    lines.append("\n### GPU:\n")
    for gpu in gpus:
      lines.append(f"- {gpu.Name}")
    lines.append("")

    # Network adapters (physical and enabled)
    net_adapters = [n for n in c.Win32_NetworkAdapter() if n.PhysicalAdapter and n.NetEnabled]
    lines.append("\n### Network Adapters:\n")
    for net in net_adapters:
      lines.append(f"- Name: {net.Name}, Connection ID: {net.NetConnectionID}, Type: {net.AdapterType}")

    # Printers info
    printers = c.Win32_Printer()
    lines.append("\n### Printers:\n")
    for printer in printers:
      lines.append(f"- Name: {printer.Name}, Port: {printer.PortName}")

    # Scanners
    scanners = [d for d in c.Win32_PnPEntity() if d.Name and "scanner" in d.Name.lower()]
    lines.append("\n### Scanners:\n")
    for device in scanners:
      name = device.Name or ""
      if "scanner" in name.lower() or "imaging" in name.lower():
        lines.append(f"- Name: {name}")
    if not scanners:
      lines.append(f"- No devices found")

  finally:
    pythoncom.CoUninitialize()

  # Write all lines to file
  with open(filename, "w", encoding="utf-8") as f:
    f.write("\n".join(lines))
  
  # Generate combined report and remove partial reports
  get_hwsw_report(context)

  # generate html report
  markdown_to_html(context)

def clean_apps(isStandardList, context: AppContext):
  # Input and output file paths
  if isStandardList:
    input_file = context.standard_apps_txt
    output_file = context.standard_apps_md
  else:
    input_file = context.store_apps_txt
    output_file = context.store_apps_md
    guid_pattern = re.compile(r"^[0-9a-fA-F\-]{36}$")
    prefixes = [
      "MicrosoftWindows.",
      "Microsoft.Windows.",
      "Microsoft.",
      "MicrosoftCorporationII."
    ]

  cleaned_names = set()

  with open(input_file, "r", encoding="utf-8") as f:
    lines = f.readlines()[3:]  # Skip headers

    for line in lines:
      line = line.strip()
      if not line:
        continue

      if not isStandardList:
        if guid_pattern.match(line):
          continue
        for prefix in prefixes:
          if line.startswith(prefix):
            line = line[len(prefix):]
            break
      else:
        if "driver" in line.lower():
          continue

      line = "- " + line
      cleaned_names.add(line)

  with open(output_file, "w", encoding="utf-8") as f:
    for name in sorted(cleaned_names):
      f.write(name + "\n")

  try:
    os.remove(input_file)
  except OSError as e:
    print(f"Error deleting {input_file}: {e}")

def get_info_thread(context: AppContext):
  # PowerShell command
  command_storeapps = 'Get-AppxPackage | Select-Object Name'

  # Run the command
  result = subprocess.run(
    ["powershell", "-Command", command_storeapps],
    capture_output=True,
    text=True
  )
  with open(context.store_apps_txt, "w", encoding="utf-8") as f:
    f.write(result.stdout)
  if result.stderr:
    print("PowerShell error:\n", result.stderr)
  clean_apps(False, context) # remove dups, empty lines, etc.

  command_standardapps = """
Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*,
                  HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |
    Select-Object DisplayName |
    Where-Object { $_.DisplayName } |
    Sort-Object DisplayName
"""
  result = subprocess.run(
    ["powershell", "-Command", command_standardapps],
    capture_output=True,
    text=True
  )
  with open(context.standard_apps_txt, "w", encoding="utf-8") as f:
    f.write(result.stdout)
  if result.stderr:
    print("PowerShell error:\n", result.stderr)

  clean_apps(True, context) # remove dups, empty lines, etc.
  get_hw_info(context) # get hardware info in markdown format
  context.root.after(0, lambda: finish_get_info(context))

def finish_get_info(context: AppContext):
  # After work
  context.stop_progress()
  context.set_root_label("Finished gathering software and hardware info")

  frame = ttk.Frame(context.root)
  frame.pack(pady=10)
  back_btn = ttk.Button(frame, text="Back", width=20, command=lambda: launch_novice_mode(context))
  back_btn.grid(row=0, column=0, padx=10, pady=5, sticky="w")
  home_btn = ttk.Button(frame, text="Home", width=20, command=lambda: home(context))
  home_btn.grid(row=0, column=1, padx=10, pady=5, sticky="w")
  view_btn = ttk.Button(frame, text="View report", width=20, command=lambda: open_link(f"file://{os.path.abspath(context.html_report)}"))
  view_btn.grid(row=0, column=2, padx=10, pady=5, sticky="e")
  next_btn = ttk.Button(frame, text="Next", width=20, command=lambda: backup_novice(context))
  next_btn.grid(row=0, column=3, padx=10, pady=5, sticky="e")
  context.quit_button()

def backup_novice(context: AppContext):
  context.set_root_title("Let's back up your data")
  clear_screen(context)
  get_status(2, True, context)
  context.set_root_label("Let's back up your data")
  context.quit_button()

def get_info(context: AppContext):
  context.set_root_title("Gathering software and hardware info")
  clear_screen(context)
  get_status(1, True, context)
  context.set_root_label("Now we are gathering software and hardware info")

  #  global progress 
  context.start_progress()

def clear_screen(context: AppContext):
  for widget in context.root.winfo_children():
    widget.destroy()

def launch_novice_mode(context: AppContext):
  context.set_root_title("LMTK: Are you familiar with Linux?")
  clear_screen(context)
  context.set_root_label("LMTK: Are you familiar with Linux?")
  get_status(0, True, context)
  text_frame = ttk.Frame(context.root)
  text_frame.pack(padx=10, pady=10, fill="x")
  text_frame.configure(height=200)  
  scrollbar = ttk.Scrollbar(text_frame, orient="vertical")
  scrollbar.pack(side="right", fill="y")
  guide_content = """\
So, you're going to install Linux. But are you familiar with Linux?

If not, there are some resources to help you master it without too much risk:
- Git for Windows -- includes bash and core command-line utilities, as well as vim text editor.
- VirtualBox -- you'll be able to install and play any Linux distribution you like in a sandbox.
- LiveCD -- you'll be able to boot into Linux and at least check if your hardware works.

The most common question you get , is 'What distribution should I use?'
Well, I recommend Ubuntu or Fedora to have a pleasant start.

The next question is 'What desktop environment should I use?'
I recommend Gnome if you have enough memory or XFCE, if you don't. :)

Here are some links (all of them are LiveCDs, by the way):
- Fedora (Gnome-based)
- Fedora XFCE
- Ubuntu (Gnome-based)
- Ubuntu XFCE

When you click 'Next', we'll gather information about your software and hardware, save it as Markdown (.md) and HTML (.html) reports for future use.
"""
  text = tk.Text(text_frame, height=25, width=100, wrap="word", font=("Helvetica", 11), bd=0, bg=context.root.cget("bg"), relief="flat", highlightthickness=0, yscrollcommand=scrollbar.set)
  text.pack(side="left", fill="both", expand=True)
  text.insert("1.0", guide_content)
  scrollbar.config(command=text.yview)
  text.tag_config("line_spacing", spacing3=6)  # spacing in pixels
  text.tag_add("line_spacing", "1.0", "end")
  text.config(state="disabled")

  links = [
    ("link_gitForWindows", "4.2", "4.17", "https://git-scm.com/downloads/win"),
    ("link_virtualbox", "5.2", "5.12", "https://www.virtualbox.org/wiki/Downloads"),
    ("link_fedora_gnome", "15.2", "15.22", "https://fedoraproject.org/workstation/download"),
    ("link_fedora_xfce", "16.2", "16.13", "https://fedoraproject.org/spins/xfce/download"),
    ("link_ubuntu_gnome", "17.2", "17.23", "https://ubuntu.com/download/desktop"),
    ("link_ubuntu_xfce", "18.2", "18.13", "https://xubuntu.org/download/"),
    ]

  for tag, start, end, url in links:
    text.tag_add(tag, start, end)
    text.tag_config(tag, foreground="blue")
    text.tag_bind(tag, "<Button-1>", lambda event, url=url: open_link(url))

  text.config(state=tk.DISABLED)

  # buttons
  button_frame = ttk.Frame(context.root)
  button_frame.pack(padx=10, pady=10, anchor="center")
  home_btn = ttk.Button(button_frame, text="Home", width=20, command=lambda: home(context))
  home_btn.grid(row=0, column=0, padx=10, pady=5, sticky="w")
  next_btn = ttk.Button(button_frame, text="Next", width=20, command=lambda: get_info(context))
  next_btn.grid(row=0, column=1, padx=10, pady=5, sticky="e")
  context.quit_button()

def launch_expert_mode(context: AppContext):
  print("Expert Mode selected")

def is_powershell_installed():
  try:
    subprocess.run(
      ["powershell", "-Command", "Write-Output 'OK'"],
      stdout=subprocess.DEVNULL,
      stderr=subprocess.DEVNULL,
      check=True
      )
    return True
  except (FileNotFoundError, subprocess.CalledProcessError):
    return False

def home(context: AppContext):
  clear_screen(context)
  context.set_root_title("Welcome to Linux Migration Toolkit!")
  context.set_root_label("Welcome to Linux Migration Toolkit! Choose Your Mode")

  # general info
  text_intro = "Welcome to the Linux Migration Toolkit for the desktop! This app gathers information about your installed programs and hardware for future use, helps you back up your data, and assists in preparing installation media using external tools."
  intro_text = ttk.Label(context.root, text=text_intro, wraplength=600, justify="left")
  intro_text.pack(padx=20, pady=20)

  # buttons
  frame = ttk.Frame(context.root)
  frame.pack(pady=10)
  novice_btn = ttk.Button(frame, text="Novice Mode", width=20, command=lambda: launch_novice_mode(context))
  novice_btn.grid(row=0, column=0, padx=10, pady=5, sticky="n")
  novice_desc = ttk.Label(frame, text="For each step you'll have useful guidance and links.\nAlso use it if you use this program for the first time.", justify="left", wraplength=400)
  novice_desc.grid(row=0, column=1, padx=10, sticky="w")

  expert_btn = ttk.Button(frame, text="Expert Mode", width=20, command=lambda: launch_expert_mode(context))
  expert_btn.grid(row=1, column=0, padx=10, pady=5, sticky="n")
  expert_desc = ttk.Label(frame, text="You know what the program does.", justify="left", wraplength=400)
  expert_desc.grid(row=1, column=1, padx=10, sticky="w")

  # PowerShell check
  text_ps_installed = "PowerShell is installed. We'll need it to do some stuff."
  text_ps_not_installed = "PowerShell is not installed. Please install it and restart the app."

  if is_powershell_installed():
    ps_text = ttk.Label(context.root, text=text_ps_installed, wraplength=600, justify="left")
    ps_text.pack(padx=20, pady=20)
  else:
    ps_text = ttk.Label(context.root, text=text_ps_not_installed, wraplength=600, justify="left")
    ps_text.pack(padx=20, pady=20)
    novice_btn.config(state="disabled")
    expert_btn.config(state="disabled")

  context.quit_button()

  reddit_text = ttk.Label(context.root, text="Thanks to all the guys and gals in reddit.com/r/linuxsucks/, you're my inspiration.", wraplength=600, justify="left")
  reddit_text.pack(padx=20, pady=20)

context = AppContext()
home(context)
context.run()

