# LMTK creates report about hardware and software in windows, backs up data and displays info about creating installation media
# Copyright (C) 2025 Konstantin Ovchinnikov k@kovchinnikov.info
# This file is part of LMTK, licensed under the GNU GPLv3 or later.
# See the LICENSE file or <https://www.gnu.org/licenses/> for details.

from i18n import _
import os # remove old files
from tkinter import ttk
import pythoncom # for hardware detection
import markdown # convert report from markdown to html
import subprocess # execute PowerShell scripts for hardware detection
import re # edit text files, generated by PowerShell
import wmi # hardware detection in Windows
from datetime import datetime # timestamp in report
from app_context import AppContext

class Report():
  def markdown_to_html(self, context: AppContext):
    # Read markdown content
    with open(context.md_report, "r", encoding="utf-8") as f:
      text = f.read()

    # Convert to HTML
    html = markdown.markdown(text, extensions=["fenced_code", "tables", "toc", "attr_list"])

    # Wrap in basic HTML boilerplate
    full_html = f"""<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>{_('Linux Migration Toolkit Report')}</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
</head>
<body>
<main class="container">
{html}
</main>
</body>
</html>
"""

    # Write HTML file
    with open(context.html_report, "w", encoding="utf-8") as f:
      f.write(full_html)

  def get_hwsw_report(self, context: AppContext):
    from i18n import _
    file1 = context.standard_apps_md
    file2 = context.store_apps_md
    file3 = context.hw_report_md
    output_file = context.md_report
    # Titles
    main_title = f"# {_('Linux Migration Toolkit Report')}"
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    sections = [
      (f"## {_('Standard Applications')}", file1),
      (f"## {_('Microsoft Store Applications')}", file2),
      (f"## {_('Hardware Information')}", file3),
  ]

    # Combine files into one markdown report
    with open(output_file, "w", encoding="utf-8") as out:
      out.write(f"""
{main_title}

*{_('Generated on')} {timestamp}*

## {_('What do I do with this information?')}

{_('You can use this report to')}:

- {_('Check your hardware\'s compatibility with Linux')}.
- {_('Find Linux alternatives for the Windows programs you currently use')}.

{_('Helpful resources')}:

- [Ubuntu Hardware Support Wiki](https://wiki.ubuntu.com/HardwareSupport)
- [{_('Linux software equivalents to Windows software')}](https://wiki.linuxquestions.org/wiki/Linux_software_equivalent_to_Windows_software)\n\n

## {_('Table of Contents')}

- [{_('Standard Applications')}](#standard-applications) &dash; {_('these apps are installed, when you download and installation file and launch it')}
- [{_('Microsoft Store Applications')}](#microsoft-store-applications) &dash; {_('these are the apps, installed from Microsoft Store')}
- [{_('Hardware Information')}](#hardware-information) &dash; {_('some basic information about your system')}: CPU, GPU, RAM, HDD/SSD\n
""")

      for header, filename in sections:
        out.write(f"{header}\n\n")
        with open(filename, "r", encoding="utf-8") as f:
          out.write(f.read().strip() + "\n\n")

    # Remove original files
    for _, filename in sections:
      try:
        os.remove(filename)
      except OSError as e:
        print(f"{_('Error deleting')} {filename}: {e}")

  def get_hw_info(self, context: AppContext):
    filename = context.hw_report_md
    pythoncom.CoInitialize()
    try:
      c = wmi.WMI()
      lines = []

      # CPU info
      cpus = c.Win32_Processor()
      lines.append("### CPU:\n")
      for cpu in cpus:
        lines.append(f"- {_('Name')}: {cpu.Name}")
        lines.append(f"- {_('Number of Cores')}: {cpu.NumberOfCores}")

      # RAM info (in GB)
      system_info = c.Win32_ComputerSystem()[0]
      total_ram_bytes = int(system_info.TotalPhysicalMemory)
      total_ram_gb = total_ram_bytes / (1024 ** 3)
      lines.append(f"\n### RAM:\n\n- {total_ram_gb:.2f} GB")

      # Drives info
      drives = c.Win32_LogicalDisk(DriveType=3)  # local disks only
      lines.append(f"\n### {_('Drives')}:\n")
      for drive in drives:
        size_gb = int(drive.Size) / (1024 ** 3) if drive.Size else 0
        free_gb = int(drive.FreeSpace) / (1024 ** 3) if drive.FreeSpace else 0
        lines.append(f"- {drive.DeviceID} - {_('Size')}: {size_gb:.2f} GB, {_('Free')}: {free_gb:.2f} GB")

      # GPU info
      gpus = c.Win32_VideoController()
      lines.append("\n### GPU:\n")
      for gpu in gpus:
        lines.append(f"- {gpu.Name}")
      lines.append("")

      # Network adapters (physical and enabled)
      net_adapters = [n for n in c.Win32_NetworkAdapter() if n.PhysicalAdapter and n.NetEnabled]
      lines.append(f"\n### {_('Network Adapters:')}\n")
      for net in net_adapters:
        lines.append(f"- {_('Name')}: {net.Name}, {_('Connection ID')}: {net.NetConnectionID}, {_('Type')}: {net.AdapterType}")

      # Printers info
      printers = c.Win32_Printer()
      lines.append(f"\n### {_('Printers')}:\n")
      for printer in printers:
        lines.append(f"- {_('Name')}: {printer.Name}, {_('Port')}: {printer.PortName}")

      # Scanners
      scanners = [d for d in c.Win32_PnPEntity() if d.Name and "scanner" in d.Name.lower()]
      lines.append(f"\n### {_('Scanners')}:\n")
      for device in scanners:
        name = device.Name or ""
        if "scanner" in name.lower() or "imaging" in name.lower():
          lines.append(f"- {_('Name')}: {name}")
      if not scanners:
        lines.append(f"- {_('No devices found')}")

    finally:
      pythoncom.CoUninitialize()

    # Write all lines to file
    with open(filename, "w", encoding="utf-8") as f:
      f.write("\n".join(lines))
    
    # Generate combined report and remove partial reports
    self.get_hwsw_report(context)

    # generate html report
    self.markdown_to_html(context)

  def clean_apps(self, isStandardList, context: AppContext):
    # Input and output file paths
    if isStandardList:
      input_file = context.standard_apps_txt
      output_file = context.standard_apps_md
    else:
      input_file = context.store_apps_txt
      output_file = context.store_apps_md
      guid_pattern = re.compile(r"^[0-9a-fA-F\-]{36}$")
      prefixes = [
        "MicrosoftWindows.",
        "Microsoft.Windows.",
        "Microsoft.",
        "MicrosoftCorporationII."
      ]

    cleaned_names = set()

    with open(input_file, "r", encoding="utf-8") as f:
      lines = f.readlines()[3:]  # Skip headers

      for line in lines:
        line = line.strip()
        if not line:
          continue

        if not isStandardList:
          if guid_pattern.match(line):
            continue
          for prefix in prefixes:
            if line.startswith(prefix):
              line = line[len(prefix):]
              break
        else:
          if "driver" in line.lower():
            continue

        line = "- " + line
        cleaned_names.add(line)

    with open(output_file, "w", encoding="utf-8") as f:
      for name in sorted(cleaned_names):
        f.write(name + "\n")

    try:
      os.remove(input_file)
    except OSError as e:
      print(f"{_('Error deleting')} {input_file}: {e}")

  def get_info_thread(self, context: AppContext):
    # PowerShell command
    command_storeapps = 'Get-AppxPackage | Select-Object Name'

    # Run the command
    result = subprocess.run(
      ["powershell", "-Command", command_storeapps],
      capture_output=True,
      text=True
    )
    with open(context.store_apps_txt, "w", encoding="utf-8") as f:
      f.write(result.stdout)
    if result.stderr:
      print("PowerShell error:\n", result.stderr)
    self.clean_apps(False, context) # remove dups, empty lines, etc.

    command_standardapps = """
Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*,
                  HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |
    Select-Object DisplayName |
    Where-Object { $_.DisplayName } |
    Sort-Object DisplayName
"""
    result = subprocess.run(
      ["powershell", "-Command", command_standardapps],
      capture_output=True,
      text=True
    )
    with open(context.standard_apps_txt, "w", encoding="utf-8") as f:
      f.write(result.stdout)
    if result.stderr:
      print("PowerShell error:\n", result.stderr)

    self.clean_apps(True, context) # remove dups, empty lines, etc.
    self.get_hw_info(context) # get hardware info in markdown format
    context.root.after(0, lambda: self.finish_get_info(context)) # called after the thread finishes

  def finish_get_info(self, context: AppContext):
    context.stop_progress()
    context.set_report_label(_("Finished gathering software and hardware info"))
    context.view_btn.config(state="normal")
    context.report_generated = True

