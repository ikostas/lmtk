# LMTK creates report about hardware and software in windows, backs up data and displays info about creating installation media
# Copyright (C) 2025 Konstantin Ovchinnikov k@kovchinnikov.info
# This file is part of LMTK, licensed under the GNU GPLv3 or later.
# See the LICENSE file or <https://www.gnu.org/licenses/> for details.

'''
Module: report.py
Description: Generates report in Markdown and HTML about software installed and hardware
'''

import os # remove old files
import subprocess # execute PowerShell scripts for hardware detection
from datetime import datetime # timestamp in report
import re # edit text files, generated by PowerShell
import pythoncom # for hardware detection
import markdown # convert report from markdown to html
import wmi # hardware detection in Windows
from i18n import _
from app_context import AppContext

class Report():
  """Functions to generate html and Markdown report"""
  def markdown_to_html(self, context: AppContext):
    """Convert Markdown files to a single html report"""
    # Read markdown content
    with open(context.md_report, "r", encoding="utf-8") as f:
      text = f.read()

    # Convert to HTML
    html = markdown.markdown(text, extensions=["fenced_code", "tables", "toc", "attr_list"])

    # Wrap in basic HTML boilerplate
    full_html = f"""<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>{_('Linux Migration Toolkit Report')}</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
</head>
<body>
<main class="container">
{html}
</main>
</body>
</html>
"""

    # Write HTML file
    with open(context.html_report, "w", encoding="utf-8") as f:
      f.write(full_html)

  def get_hwsw_report(self, context: AppContext):
    """Generate Markdown report about hardware and software registered"""
    from i18n import _
    file1 = context.standard_apps_md
    file2 = context.store_apps_md
    file3 = context.hw_report_md
    output_file = context.md_report
    # Titles
    main_title = f"# {_('Linux Migration Toolkit Report')}"
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    sections = [
      (f"## {_('Standard Applications')}", file1),
      (f"## {_('Microsoft Store Applications')}", file2),
      (f"## {_('Hardware Information')}", file3),
  ]

    # Combine files into one markdown report
    with open(output_file, "w", encoding="utf-8") as out:
      out.write(f"""
{main_title}

*{_('Generated on')} {timestamp}*

## {_('What do I do with this information?')}

{_('You can use this report to')}:

- {_('Check your hardware\'s compatibility with Linux')}.
- {_('Find Linux alternatives for the Windows programs you currently use')}.

{_('Helpful resources')}:

- [Ubuntu Hardware Support Wiki](https://wiki.ubuntu.com/HardwareSupport)
- [{_('Linux software equivalents to Windows software')}](https://wiki.linuxquestions.org/wiki/Linux_software_equivalent_to_Windows_software)\n\n

## {_('Table of Contents')}

- [{_('Standard Applications')}](#standard-applications) &dash; {_('these apps are installed, when you download and installation file and launch it')}
- [{_('Microsoft Store Applications')}](#microsoft-store-applications) &dash; {_('these are the apps, installed from Microsoft Store')}
- [{_('Hardware Information')}](#hardware-information) &dash; {_('some basic information about your system')}: CPU, GPU, RAM, HDD/SSD\n
""")

      for header, filename in sections:
        out.write(f"{header}\n\n")
        with open(filename, "r", encoding="utf-8") as f:
          out.write(f.read().strip() + "\n\n")

    # Remove original files
    for _, filename in sections:
      try:
        os.remove(filename)
      except OSError as e:
        print(f"{_('Error deleting')} {filename}: {e}")

  def get_hw_info(self, context: AppContext):
    """Generate Markdown report about available hardware"""
    filename = context.hw_report_md
    pythoncom.CoInitialize()
    try:
      c = wmi.WMI()
      lines = []

      def add_section(title, items):
        lines.append(f"\n### {title}:\n")
        lines.extend(items)

      # CPU info
      cpus = c.Win32_Processor()
      add_section("CPU", [
        f"- {_('Name')}: {cpu.Name}\n- {_('Number of Cores')}: {cpu.NumberOfCores}"
        for cpu in cpus
      ])

      # RAM info
      system_info = c.Win32_ComputerSystem()[0]
      total_ram_gb = int(system_info.TotalPhysicalMemory) / (1024 ** 3)
      add_section("RAM", [f"- {total_ram_gb:.2f} GB"])

      # Drives
      drives = c.Win32_LogicalDisk(DriveType=3)
      add_section(_("Drives"), [
        f"- {d.DeviceID} - {_('Size')}: {int(d.Size)/(1024**3):.2f} GB, {_('Free')}: {int(d.FreeSpace)/(1024**3):.2f} GB"
        for d in drives
      ])

      # GPU
      gpus = c.Win32_VideoController()
      add_section("GPU", [f"- {g.Name}" for g in gpus])

      # Network adapters (filtered in WMI)
      net_adapters = c.query(
        "SELECT * FROM Win32_NetworkAdapter WHERE PhysicalAdapter=True AND NetEnabled=True"
      )
      add_section(_("Network Adapters"), [
        f"- {_('Name')}: {n.Name}, {_('Connection ID')}: {n.NetConnectionID}, {_('Type')}: {n.AdapterType}"
        for n in net_adapters
      ])

      # Printers
      printers = c.Win32_Printer()
      add_section(_("Printers"), [
        f"- {_('Name')}: {p.Name}, {_('Port')}: {p.PortName}"
        for p in printers
      ])

      # Scanners (filtered in WMI)
      scanners = c.query(
        "SELECT * FROM Win32_PnPEntity WHERE Name LIKE '%scanner%' OR Name LIKE '%imaging%'"
      )
      if scanners:
        add_section(_("Scanners"), [f"- {_('Name')}: {s.Name}" for s in scanners])
      else:
        add_section(_("Scanners"), [f"- {_('No devices found')}"])
    finally:
      pythoncom.CoUninitialize()

    # Write all lines to file
    with open(filename, "w", encoding="utf-8") as f:
      f.write("\n".join(lines))

    # Generate combined report and remove partial reports
    self.get_hwsw_report(context)

    # generate html report
    self.markdown_to_html(context)

  def clean_apps(self, is_standard_list, context: AppContext):
    """Clean a list of apps created by PowerShell"""
    # Input and output file paths
    if is_standard_list:
      input_file = context.standard_apps_txt
      output_file = context.standard_apps_md
    else:
      input_file = context.store_apps_txt
      output_file = context.store_apps_md
      guid_pattern = re.compile(r"^[0-9a-fA-F\-]{36}$")
      prefixes = [
        "MicrosoftWindows.",
        "Microsoft.Windows.",
        "Microsoft.",
        "MicrosoftCorporationII."
      ]

    cleaned_names = set()

    with open(input_file, "r", encoding="utf-8") as f:
      lines = f.readlines()[3:]  # Skip headers

      for line in lines:
        line = line.strip()
        if not line:
          continue

        if not is_standard_list:
          if guid_pattern.match(line):
            continue
          for prefix in prefixes:
            if line.startswith(prefix):
              line = line[len(prefix):]
              break
        else:
          if "driver" in line.lower():
            continue

        line = "- " + line
        cleaned_names.add(line)

    with open(output_file, "w", encoding="utf-8") as f:
      for name in sorted(cleaned_names):
        f.write(name + "\n")

    try:
      os.remove(input_file)
    except OSError as e:
      print(f"{_('Error deleting')} {input_file}: {e}")

  def get_info_thread(self, context: AppContext):
    """Launch PowerShell scripts and create Markdown and html reports"""
    # PowerShell command
    command_storeapps = 'Get-AppxPackage | Select-Object Name'

    # Run the command
    result = subprocess.run(
      ["powershell", "-Command", command_storeapps],
      capture_output=True,
      text=True,
      check=False
    )
    with open(context.store_apps_txt, "w", encoding="utf-8") as f:
      f.write(result.stdout)
    if result.stderr:
      print("PowerShell error:\n", result.stderr)
    self.clean_apps(False, context) # remove dups, empty lines, etc.

    command_standardapps = """
Get-ItemProperty HKLM:\\Software\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\*,
                  HKLM:\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\* |
    Select-Object DisplayName |
    Where-Object { $_.DisplayName } |
    Sort-Object DisplayName
"""
    result = subprocess.run(
      ["powershell", "-Command", command_standardapps],
      capture_output=True,
      text=True,
      check=False
    )
    with open(context.standard_apps_txt, "w", encoding="utf-8") as f:
      f.write(result.stdout)
    if result.stderr:
      print("PowerShell error:\n", result.stderr)

    self.clean_apps(True, context) # remove dups, empty lines, etc.
    self.get_hw_info(context) # get hardware info in markdown format
    context.root.after(0, lambda: self.finish_get_info(context)) # called after the thread finishes

  def finish_get_info(self, context: AppContext):
    """Stop progress bar and inform user when report is ready"""
    context.stop_progress()
    context.set_report_label(_("Finished gathering software and hardware info"))
    context.view_btn.config(state="normal")
    context.report_generated = True
